<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Train Network on World Map</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
#layout { display:flex; height:100vh; width:100vw; }
#controls { width:250px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
#chart { flex:1; position:relative; }
.link { stroke:#999; stroke-opacity:0.6; }
.node { stroke:#fff; stroke-width:1.2px; cursor:pointer; }
.tooltip {
  position:absolute;
  background:rgba(0,0,0,0.8);
  color:#fff;
  padding:6px 8px;
  border-radius:4px;
  font-size:13px;
  pointer-events:none;
  display:none;
}
</style>
</head>
<body>

<div id="layout">
  <div id="controls">
    <h3>Filters</h3>
    <label for="modeSelect">Mode:</label>
    <select id="modeSelect">
      <option value="city">City Node</option>
      <option value="train">Train Node</option>
    </select>
    <br><br>
    <label for="cityFilter">City:</label>
    <select id="cityFilter">
      <option value="">All Cities</option>
    </select>
  </div>
  <div id="chart"></div>
</div>

<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://d3js.org/topojson.v3.min.js"></script>
<script>
(async function(){
  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const nodesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const linksUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;
  const worldUrl = "https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json";

  // Load data
  const [nodesRaw, linksRaw, worldData] = await Promise.all([
    d3.csv(nodesUrl),
    d3.csv(linksUrl),
    d3.json(worldUrl)
  ]);

  const nodes = nodesRaw.map(d=>({
    id:d.CityID,
    label:d.CityName||d.CityID,
    lat:+d.Latitude,
    lon:+d.Longitude,
    passengers:+(d.TotalPassengers||1)
  }));

  const links = linksRaw.map(d=>({
    source:d.FromCity,
    target:d.ToCity,
    weight:+(d.PassengersPerDay||1)
  }));

  // Compute degree for cities
  nodes.forEach(n=>n.degree=0);
  links.forEach(l=>{
    const s=nodes.find(n=>n.id===l.source);
    const t=nodes.find(n=>n.id===l.target);
    if(s) s.degree+=1;
    if(t) t.degree+=1;
  });

  // Populate city filter
  const cityDropdown = d3.select('#cityFilter');
  nodes.forEach(d=>{
    cityDropdown.append('option').attr('value',d.id).text(d.label);
  });

  // SVG
  const container = d3.select('#chart');
  let width = container.node().clientWidth;
  let height = container.node().clientHeight;
  const svg = container.append('svg').attr('width',width).attr('height',height);

  // Map projection
  const projection = d3.geoNaturalEarth1().fitSize([width,height], topojson.feature(worldData, worldData.objects.countries));
  const path = d3.geoPath(projection);

  // Draw world
  svg.append("g")
    .selectAll("path")
    .data(topojson.feature(worldData, worldData.objects.countries).features)
    .join("path")
    .attr("d", path)
    .attr("fill","#e0e0e0")
    .attr("stroke","#999");

  // Scales
  const rScaleCity = d3.scaleSqrt().domain(d3.extent(nodes,d=>d.degree)).range([6,24]);
  const rScaleTrain = d3.scaleSqrt().domain(d3.extent(nodes,d=>d.passengers)).range([6,24]);
  const linkWidth = d3.scaleLinear().domain(d3.extent(links,d=>d.weight)).range([1,5]);

  // Simulation with forceXY to map positions to lat/lon
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d=>d.id).distance(50).strength(0.8))
    .force("charge", d3.forceManyBody().strength(-20))
    .force("center", d3.forceCenter(width/2,height/2))
    .force("x", d3.forceX(d=>projection([d.lon,d.lat])[0]).strength(1))
    .force("y", d3.forceY(d=>projection([d.lon,d.lat])[1]).strength(1));

  // Links
  let link = svg.append('g').attr('class','links').selectAll('line')
    .data(links).join('line')
    .attr('class','link')
    .attr('stroke-width',d=>linkWidth(d.weight));

  // Nodes
  let node = svg.append('g').attr('class','nodes').selectAll('g')
    .data(nodes).join('g')
    .call(d3.drag()
      .on('start',(event,d)=>{if(!event.active)simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;})
      .on('drag',(event,d)=>{d.fx=event.x; d.fy=event.y;})
      .on('end',(event,d)=>{if(!event.active)simulation.alphaTarget(0); d.fx=null; d.fy=null;})
    );

  node.append('circle')
    .attr('r', d=>rScaleCity(d.degree))
    .attr('fill','#3b82f6')
    .attr('class','node')
    .on('mouseover',(event,d)=>showTooltip(event,d))
    .on('mousemove',event=>moveTooltip(event))
    .on('mouseout',hideTooltip);

  node.append('text')
    .text(d=>d.label)
    .attr('x', d=>rScaleCity(d.degree)+4)
    .attr('y',4)
    .style('font-size','10px');

  // Tooltip
  const tooltip = d3.select('#tooltip');
  function showTooltip(event,d){
    const mode = d3.select('#modeSelect').property('value');
    let text = mode==='city'? `<strong>${d.label}</strong><br/>Connections: ${d.degree}`:`<strong>${d.label}</strong><br/>Passengers: ${d.passengers}`;
    tooltip.style('display','block').html(text);
    d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',1.5);
  }
  function moveTooltip(event){ tooltip.style.left=(event.pageX+12)+'px'; tooltip.style.top=(event.pageY+12)+'px'; }
  function hideTooltip(event,d){ tooltip.style.display='none'; d3.select(event.currentTarget).attr('stroke','#fff').attr('stroke-width',1.2); }

  simulation.on('tick',()=>{
    link.attr('x1',d=>d.source.x).attr('y1',d=>d.source.y)
        .attr('x2',d=>d.target.x).attr('y2',d=>d.target.y);
    node.attr('transform', d=>`translate(${d.x},${d.y})`);
  });

  function updateGraph(){
    const mode = d3.select('#modeSelect').property('value');
    const selectedCity = d3.select('#cityFilter').property('value');

    // Filter links & nodes
    let filteredLinks = selectedCity ? links.filter(l=>l.source===selectedCity || l.target===selectedCity) : links;
    let connectedNodeIds = new Set();
    filteredLinks.forEach(l=>{connectedNodeIds.add(l.source); connectedNodeIds.add(l.target);});
    let filteredNodes = selectedCity ? nodes.filter(n=>connectedNodeIds.has(n.id)) : nodes;

    simulation.nodes(filteredNodes);
    simulation.force('link').links(filteredLinks);
    simulation.alpha(0.5).restart();

    // Update link elements
    link = svg.select('g.links').selectAll('line').data(filteredLinks,d=>d.source+'-'+d.target).join('line').attr('class','link').attr('stroke-width',d=>linkWidth(d.weight));

    // Update nodes
    node = svg.select('g.nodes').selectAll('g').data(filteredNodes,d=>d.id).join('g')
      .call(d3.drag()
        .on('start',(event,d)=>{if(!event.active)simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;})
        .on('
