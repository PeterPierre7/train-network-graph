<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Train Network Graph: City / Train Mode</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  
  <!-- CSS -->
  <style>
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #layout { display:flex; height:100vh; width:100vw; margin:0; }
    #controls { width:220px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
    #chart { flex:1; height:100vh; }
    .link { stroke:#999; stroke-opacity:0.6; }
    .node { stroke:#fff; stroke-width:1.2px; cursor:pointer; }
    .tooltip {
      position:absolute;
      background:rgba(0,0,0,0.8);
      color:#fff;
      padding:6px 8px;
      border-radius:4px;
      font-size:13px;
      pointer-events:none;
      display:none;
    }
  </style>
</head>
<body>

  <!-- Layout -->
  <div id="layout">
    <!-- Sidebar controls -->
    <div id="controls">
      <h3>Filters</h3>
      <label for="modeSelect">Mode:</label>
      <select id="modeSelect">
        <option value="city">City Node</option>
        <option value="train">Train Node</option>
      </select>
      <br><br>
      <label for="cityFilter">City:</label>
      <select id="cityFilter">
        <option value="">All Cities</option>
      </select>
    </div>

    <!-- Chart container -->
    <div id="chart"></div>
  </div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip"></div>

  <!-- D3 Script -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    (async function() {
      const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
      const nodesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
      const linksUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;

      const [nodesRaw, linksRaw] = await Promise.all([d3.csv(nodesUrl), d3.csv(linksUrl)]);

      // Nodes and Links
      const nodes = nodesRaw.map(d => ({
        id: d.CityID,
        label: d.CityName || d.CityID,
        passengers: +(d.TotalPassengers || 1),
        lat: +(d.Latitude || 0),
        lon: +(d.Longitude || 0)
      }));

      const links = linksRaw.map(d => ({
        source: d.FromCity,
        target: d.ToCity,
        weight: +(d.PassengersPerDay || 1),
        distance: +(d.DistanceKm || 0)
      }));

      // Compute degree (connections) for city nodes
      nodes.forEach(n => n.degree = 0);
      links.forEach(l => {
        const s = nodes.find(n => n.id === l.source);
        const t = nodes.find(n => n.id === l.target);
        if (s) s.degree += 1;
        if (t) t.degree += 1;
      }));

      // Populate city dropdown
      const cityDropdown = d3.select('#cityFilter');
      nodes.forEach(d => {
        cityDropdown.append('option')
          .attr('value', d.id)
          .text(d.label);
      });

      // SVG setup
      const container = d3.select('#chart');
      let width = container.node().clientWidth;
      let height = container.node().clientHeight;

      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

      // Scales
      const degreeExtent = d3.extent(nodes, d=>d.degree);
      const rScaleCity = d3.scaleSqrt().domain(degreeExtent).range([6,24]);

      const passengerExtent = d3.extent(nodes, d=>d.passengers);
      const rScaleTrain = d3.scaleSqrt().domain(passengerExtent).range([6,24]);

      const weightExtent = d3.extent(links, d=>d.weight);
      const linkWidth = d3.scaleLinear().domain(weightExtent).range([1,6]);

      const maxDist = d3.max(links, d=>d.distance) || 1;
      const distScale = d3.scaleLinear().domain([0,maxDist]).range([50,300]);

      // Simulation
      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(d=>d.distance ? distScale(d.distance) : 120).strength(0.8))
        .force('charge', d3.forceManyBody().strength(-250))
        .force('center', d3.forceCenter(width/2,height/2))
        .force('collision', d3.forceCollide().radius(d=>rScaleCity(d.degree)+4));

      let link = svg.append('g').attr('class','links').selectAll('line')
        .data(links).join('line')
        .attr('class','link')
        .attr('stroke-width', d=>linkWidth(d.weight));

      let node = svg.append('g').attr('class','nodes').selectAll('g')
        .data(nodes).join('g')
        .call(d3.drag()
          .on('start',(event,d)=>{if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;})
          .on('drag',(event,d)=>{d.fx=event.x; d.fy=event.y;})
          .on('end',(event,d)=>{if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null;})
        );

      node.append('circle')
        .attr('r', d=>rScaleCity(d.degree))
        .attr('class','node')
        .attr('fill','#3b82f6')
        .on('mouseover', (event,d)=>showTooltip(event,d))
        .on('mousemove', (event)=>moveTooltip(event))
        .on('mouseout', hideTooltip);

      node.append('text')
        .text(d=>d.label)
        .attr('x', d=>rScaleCity(d.degree)+4)
        .attr('y', 4)
        .style('font-size','12px');

      // Tooltip
      const tooltip = d3.select('#tooltip');
      function showTooltip(event,d){
        const mode = d3.select('#modeSelect').property('value');
        let text = mode==='city'? `<strong>${d.label}</strong><br/>Connections: ${d.degree}` : `<strong>${d.label}</strong><br/>Passengers: ${d.passengers}`;
        tooltip.style('display','block').html(text);
        d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',1.5);
      }
      function moveTooltip(event){ tooltip.style.left=(event.pageX+12)+'px'; tooltip.style.top=(event.pageY+12)+'px'; }
      function hideTooltip(event,d){ tooltip.style.display='none'; d3.select(event.currentTarget).attr('stroke','#fff').attr('stroke-width',1.2); }

      simulation.on('tick', ()=>{
        link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
        node.attr('transform', d=>`translate(${d.x},${d.y})`);
      });

      // Update function for filter/mode
      function updateGraph(){
        const mode = d3.select('#modeSelect').property('value');
        const selectedCity = d3.select('#cityFilter').property('value');

        // Filter links and nodes
        let filteredLinks = selectedCity ? links.filter(l=>l.source===selectedCity || l.target===selectedCity) : links;
        let connectedNodeIds = new Set();
        filteredLinks.forEach(l=>{connectedNodeIds.add(l.source); connectedNodeIds.add(l.target);});
        let filteredNodes = selectedCity ? nodes.filter(n=>connectedNodeIds.has(n.id)) : nodes;

        // Update simulation
        simulation.nodes(filteredNodes);
        simulation.force('link').links(filteredLinks);
        simulation.alpha(0.5).restart();

        // Update links
        link = svg.select('g.links').selectAll('line').data(filteredLinks,d=>d.source+'-'+d.target).join('line').attr('class','link').attr('stroke-width',d=>
