<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Train Network - Curved One-Way Links</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
    body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    #layout { display:flex; height:100vh; width:100vw; margin:0; }
    #controls { width:220px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
    #controls select { width: 100%; margin-bottom: 15px; padding: 5px; }
    #chart { flex:1; height:100vh; display:flex; flex-direction:column; }

    /* Map Styles */
    .country {
        fill: #e0e0e0;
        stroke: #ccc;
        stroke-width: 0.5px;
    }
    .sphere {
        fill: #f0f8ff;
    }
    .map-element { transition: opacity 0.5s; }

    .node circle { stroke:#fff; stroke-width:1.5px; cursor:pointer; }
    .node text {
        font-weight: bold;
        fill: #000;
        pointer-events:none;
        text-anchor: middle;
        dominant-baseline: central;
        text-shadow: 0 0 3px #ccc, 0 0 3px #ccc, 0 0 3px #ccc;
    }
    .link { fill:none; cursor:pointer; }

    .link-label { display:none; }

    .tooltip {
        position:absolute;
        background:rgba(0,0,0,0.8);
        color:#fff;
        padding:8px 12px;
        border-radius:4px;
        font-size:14px;
        pointer-events:none;
        display:none;
        line-height:1.4;
    }
    .tooltip strong { color:#ffcc00; }
    .green-text { color:lightgreen; }
    .red-text { color:red; }
    #mapToggle {
        padding:8px 10px;
        margin-top:10px;
        width:100%;
        cursor:pointer;
        background-color:#007bff;
        color:white;
        border:none;
        border-radius:4px;
        font-weight:bold;
    }
    #mapToggle.active { background-color:#28a745; }

    #summary {
        text-align:center;
        padding:8px;
        font-size:14px;
        background:#f0f8f0;
        border-bottom:1px solid #ccc;
        font-weight:bold;
    }
</style>
</head>
<body>
<div id="layout">
  <div id="controls">
    <h3>Filter</h3>
    <label for="cityFilter">City:</label>
    <select id="cityFilter"></select>
    <hr style="margin:15px 0;border:none;border-top:1px solid #ccc;">
    <label for="animalFilter">Animal:</label>
    <select id="animalFilter"></select>
    <hr style="margin:15px 0;border:none;border-top:1px solid #ccc;">
    <label for="reciprocalFilter">Route Type:</label>
    <select id="reciprocalFilter">
      <option value="all">Show All Routes</option>
      <option value="reciprocal">Only Reciprocal (Two-way)</option>
      <option value="one-way">Only One-way</option>
    </select>
    <button id="mapToggle" class="active">Toggle Map (ON)</button>
  </div>

  <div id="chart">
    <div id="summary">
      <span style="color:green;">Green = Animal <-> Reciprocal</span> |
      <span style="color:red;">Red = One-way Animal (-> or <-)</span>
    </div>
  </div>
</div>
<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script>
(async function(){

  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const citiesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const routesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;
  
  const world = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(citiesUrl), d3.csv(routesUrl)]);

  const nodes = nodesRaw.map(d => ({
    id: d.CityName,
    label: d.CityName,
    animals: d.HouseAnimals ? d.HouseAnimals.split(',').map(a => a.trim()) : [],
    longitude:+d.Longitude,
    latitude:+d.Latitude,
    degree:0,
    fx:null, fy:null, x:0, y:0
  }));

  const links = linksRaw.map(d => ({
    source:d.FromCity,
    target:d.ToCity,
    Animals:d.Animals,
    RouteID:d.RouteID,
    isReciprocal:false
  }));

  const reciprocalRoutes = {};
  links.forEach(l=>{
    const s=nodes.find(n=>n.id===l.source);
    const t=nodes.find(n=>n.id===l.target);
    if(s)s.degree++; if(t)t.degree++;
    const key=[l.source,l.target].sort().join('|')+'|'+l.Animals;
    reciprocalRoutes[key]=(reciprocalRoutes[key]||[]).concat(l);
  });
  links.forEach(l=>{
    const key=[l.source,l.target].sort().join('|')+'|'+l.Animals;
    const pair=reciprocalRoutes[key];
    if(pair.length===2){pair.forEach(r=>r.isReciprocal=true);}
  });

  const uniqueDisplayLinks={}, aggregatedAnimals={};
  links.forEach(l=>{
    const pairKey=[l.source,l.target].sort().join('|');
    aggregatedAnimals[pairKey]=aggregatedAnimals[pairKey]||[];
    const animalObj={name:l.Animals,isReciprocal:l.isReciprocal,source:l.source,target:l.target};
    if(!aggregatedAnimals[pairKey].some(a=>a.name===animalObj.name && a.source===animalObj.source && a.target===animalObj.target))
      aggregatedAnimals[pairKey].push(animalObj);
    const displayKey=l.isReciprocal?pairKey+'|reciprocal':l.source+'|'+l.target+'|one-way';
    if(!uniqueDisplayLinks[displayKey])
      uniqueDisplayLinks[displayKey]={source:l.source,target:l.target,isReciprocal:l.isReciprocal,cityPair:pairKey,directionKey:l.source+'->'+l.target};
  });

  const labeledLinks=Object.values(uniqueDisplayLinks);
  labeledLinks.forEach(l=>{
    l.source=nodes.find(n=>n.id===l.source)||l.source;
    l.target=nodes.find(n=>n.id===l.target)||l.target;
  });

  const pathGroups={};
  labeledLinks.forEach(l=>{
    const k=[l.source.id,l.target.id].sort().join('|');
    pathGroups[k]=pathGroups[k]||[];
    pathGroups[k].push(l);
  });

  Object.values(pathGroups).forEach(g=>{
    const rec=g.find(l=>l.isReciprocal);
    const oneWay=g.filter(l=>!l.isReciprocal);
    if(rec)rec.pathIndex=0;
    oneWay.forEach((l,i)=>l.pathIndex=i+1);
  });

  const animalSet=new Set();
  links.forEach(l=>{if(l.Animals)animalSet.add(l.Animals.trim());});
  nodes.forEach(n=>n.animals.forEach(a=>animalSet.add(a)));

  const animalDropdown=d3.select('#animalFilter');
  animalDropdown.append('option').attr('value','all').text('Show All');
  Array.from(animalSet).sort().forEach(a=>animalDropdown.append('option').attr('value',a).text(a));
  const cityDropdown=d3.select('#cityFilter');
  cityDropdown.append('option').attr('value','all').text('Show All');
  nodes.map(d=>d.id).sort().forEach(c=>cityDropdown.append('option').attr('value',c).text(c));
  const reciprocalDropdown=d3.select('#reciprocalFilter');

  const container=d3.select('#chart');
  const width=container.node().clientWidth;
  const height=container.node().clientHeight-30;
  const svg=container.append('svg').attr('width',width).attr('height',height);
  const g=svg.append('g');

  const projection=d3.geoMercator().fitSize([width,height],topojson.feature(world,world.objects.countries));
  const path=d3.geoPath().projection(projection);
  g.append("path").attr("class","sphere map-element").attr("d",path({type:"Sphere"}));
  g.append("g").attr("class","countries map-element")
   .selectAll("path").data(topojson.feature(world,world.objects.countries).features)
   .join("path").attr("class","country").attr("d",path);

  nodes.forEach(d=>{
    const [x,y]=projection([d.longitude,d.latitude]);
    d.x=d.fx=x; d.y=d.fy=y;
  });

  const simulation=d3.forceSimulation(nodes)
    .force('link',d3.forceLink(labeledLinks).id(d=>d.id).distance(150).strength(0.05))
    .alpha(0.1).alphaTarget(0);
  simulation.force('charge',null).force('center',null).force('collision',null);

  let isMapMode=true;
  const curvature=0.5;
  const mapBaseRadius=4;

  g.append('defs').append('marker').attr('id','arrowhead-green-start')
    .attr('viewBox','-0 -5 10 10').attr('refX',-10).attr('refY',0).attr('markerWidth',6)
    .attr('markerHeight',6).attr('orient','auto-start-reverse')
    .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','green');
  g.append('defs').append('marker').attr('id','arrowhead-green-end')
    .attr('viewBox','-0 -5 10 10').attr('refX',10).attr('refY',0).attr('markerWidth',6)
    .attr('markerHeight',6).attr('orient','auto')
    .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','green');
  g.append('defs').append('marker').attr('id','arrowhead-red-end')
    .attr('viewBox','-0 -5 10 10').attr('refX',10).attr('refY',0).attr('markerWidth',6)
    .attr('markerHeight',6).attr('orient','auto')
    .append('path').attr('d','M0,-5L10,0L0,5').attr('fill','red');

  const link=g.append('g').attr('class','links')
    .selectAll('path').data(labeledLinks).join('path').attr('class','link')
    .attr('stroke',d=>d.isReciprocal?'green':'red')
    .attr('marker-start',d=>d.isReciprocal?'url(#arrowhead-green-start)':null)
    .attr('marker-end',d=>d.isReciprocal?'url(#arrowhead-green-end)':'url(#arrowhead-red-end)');

  const node=g.append('g').attr('class','nodes')
    .selectAll('g').data(nodes).join('g').attr('class','node');
  node.append('circle').attr('fill','#3b82f6').attr('r',mapBaseRadius);
  node.append('text').text(d=>d.label);

  const tooltip=d3.select('#tooltip');

  function getLinkTooltipContent(d){
    const pair=d.cityPair;
    const all=aggregatedAnimals[pair]||[];
    const rec=[...new Map(all.filter(a=>a.isReciprocal).map(i=>[i.name,i])).values()];
    const one=all.filter(a=>!a.isReciprocal);
    const src=d.source.label||d.source.id, tgt=d.target.label||d.target.id;
    let html=`<strong>Route: ${src} â†” ${tgt}</strong><hr style="margin:5px 0;border:none;border-top:1px solid #ccc;"/>`;
    if(rec.length>0) html+=rec.map(a=>`<span class="green-text">${a.name} <-></span>`).join('<br/>')+'<br/>';
    if(one.length>0){
      html+=one.map(a=>{
        const sym=(a.source===d.source.id&&a.target===d.target.id)?'->':'<-';
        return `<span class="red-text">${a.name} ${sym}</span>`;
      }).join('<br/>');
    }
    if(rec.length===0&&one.length===0) html+="<em>No animal routes found.</em>";
    return html;
  }

  function updateTooltip(event,d){
    tooltip.style('display','block').html(getLinkTooltipContent(d))
      .style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px');
  }

  link.on('mouseover',updateTooltip).on('mousemove',updateTooltip)
      .on('mouseout',()=>tooltip.style('display','none'));

  simulation.on('tick',()=>{
    node.attr('transform',d=>`translate(${d.x},${d.y})`);
    link.attr('d',d=>{
      const sx=d.source.x,sy=d.source.y,tx=d.target.x,ty=d.target.y;
      const dx=tx-sx,dy=ty-sy,dist=Math.sqrt(dx*dx+dy*dy);
      if(dist===0)return null;
      if(d.pathIndex===0){
        return `M${sx},${sy}L${tx},${ty}`;
      } else {
        const curveDir=(d.pathIndex%2===0)?1:-1;
        const dr=dist*curvature;
        return `M${sx},${sy}A${dr},${dr} 0 0,${curveDir>0?1:0} ${tx},${ty}`;
      }
    });
  });

})();
</script>
</body>
</html>
