<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Train Network - Disappearing Nodes</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
    body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    #layout { display:flex; height:100vh; width:100vw; margin:0; }
    #controls { width:220px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
    #controls select { width: 100%; margin-bottom: 15px; padding: 5px; }
    #chart { flex:1; height:100vh; }
    .node circle { stroke:#fff; stroke-width:1.5px; cursor:pointer; }
    .node text { 
        font-size:10px; /* Smaller font size for inside the circle */
        fill: #fff; /* White text for contrast inside the blue circle */
        pointer-events:none; 
        text-anchor: middle; /* Center the text horizontally */
        dominant-baseline: central; /* Center the text vertically */
    }
    .link { fill:none; cursor:pointer; }
    /* Style for the link labels */
    .link-label text {
        font-size: 11px;
        font-weight: bold;
        fill: #333; 
        pointer-events: none; 
        text-shadow: 0 0 4px #fff, 0 0 4px #fff; 
    }
    .tooltip { 
        position:absolute; 
        background:rgba(0,0,0,0.8); 
        color:#fff; 
        padding:8px 12px;
        border-radius:4px; 
        font-size:14px;
        pointer-events:none; 
        display:none; 
        line-height: 1.4;
    }
</style>
</head>
<body>

<div id="layout">
  <div id="controls">
    <h3>Filter</h3>
    <label for="cityFilter">City:</label>
    <select id="cityFilter">
      </select>
    <hr style="margin: 15px 0; border-top: 1px solid #ccc;">
    <label for="animalFilter">Animal:</label>
    <select id="animalFilter">
      </select>
  </div>
  <div id="chart"></div>
</div>
<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function(){

  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const citiesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const routesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;

  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(citiesUrl), d3.csv(routesUrl)]);

  const nodes = nodesRaw.map(d => ({
    id: d.CityName,
    label: d.CityName,
    animals: d.HouseAnimals ? d.HouseAnimals.split(',').map(a => a.trim()) : [],
    degree: 0
  }));

  const links = linksRaw.map(d => ({
    source: d.FromCity,
    target: d.ToCity,
    Animals: d.Animals,
    RouteID: d.RouteID,
    isReciprocal: false
  }));

  links.forEach(l => {
    const s = nodes.find(n => n.id === l.source);
    const t = nodes.find(n => n.id === l.target);
    if(s) s.degree += 1;
    if(t) t.degree += 1;
  });

  // LOGIC: Identify and flag reciprocal links
  const linkKeyMap = {};
  links.forEach(link => {
      const directionalKey = `${link.source}|${link.target}|${link.Animals}`;
      const reverseKey = `${link.target}|${link.source}|${link.Animals}`;

      if (linkKeyMap[reverseKey]) {
          link.isReciprocal = true;
          linkKeyMap[reverseKey].isReciprocal = true;
      }
      
      linkKeyMap[directionalKey] = link;
  });

  // Filter links for unique reciprocal label display
  const labeledLinks = links.filter(d => {
      if (d.isReciprocal) {
          const [cityA, cityB] = [d.source, d.target].sort();
          return d.source === cityA;
      }
      return true;
  });

  // --- Dropdown Population ---
  const animalSet = new Set();
  links.forEach(l => { if(l.Animals) animalSet.add(l.Animals.trim()); });
  nodes.forEach(n => n.animals.forEach(a => animalSet.add(a)));
  
  const animalDropdown = d3.select('#animalFilter');
  animalDropdown.append('option').attr('value', 'all').text('Show All');
  Array.from(animalSet).sort().forEach(a => {
    animalDropdown.append('option').attr('value', a).text(a);
  });
  
  const cityDropdown = d3.select('#cityFilter');
  cityDropdown.append('option').attr('value', 'all').text('Show All');
  nodes.map(d => d.id).sort().forEach(city => {
    cityDropdown.append('option').attr('value', city).text(city);
  });

  const container = d3.select('#chart');
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;
  const svg = container.append('svg').attr('width', width).attr('height', height);

  // ðŸ‘‡ NEW: Create a main 'g' element for all graph elements to be zoomed/panned
  const g = svg.append('g'); 

  // Define arrowheads (moved to g for them to be zoomed with the rest)
  g.append('defs').append('marker')
    .attr('id', 'arrowhead-green')
    .attr('viewBox', '-0 -5 10 10')
    .attr('refX', 10)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', 'green');

  g.append('defs').append('marker')
    .attr('id', 'arrowhead-red')
    .attr('viewBox', '-0 -5 10 10')
    .attr('refX', 10)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', 'red');

  const rScale = d3.scaleSqrt().domain(d3.extent(nodes, d => d.degree)).range([6, 24]);

  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(200).strength(0.8)) 
    .force('charge', d3.forceManyBody().strength(-150)) 
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collision', d3.forceCollide().radius(d => rScale(d.degree) + 5));

  // --- Link Path Drawing Group (appended to g) ---
  const link = g.append('g').attr('class', 'links')
    .selectAll('path')
    .data(links)
    .join('path')
    .attr('class', 'link')
    .attr('stroke-width', 2.5)
    .attr('stroke', d => d.isReciprocal ? 'green' : 'red')
    .attr('marker-end', d => d.isReciprocal ? 'url(#arrowhead-green)' : 'url(#arrowhead-red)');

  // --- Link Label Group (appended to g) ---
  const linkLabel = g.append('g').attr('class', 'link-labels')
    .selectAll('g')
    .data(labeledLinks)
    .join('g')
    .attr('class', 'link-label');

  linkLabel.append('text')
    .attr('dy', -3)
    .attr('text-anchor', 'middle')
    .text(d => d.Animals); 

  // --- Node Group (appended to g) ---
  const node = g.append('g').attr('class', 'nodes')
    .selectAll('g')
    .data(nodes)
    .join('g')
    .attr('class', 'node')
    .call(d3.drag()
      .on('start', (event,d) => { 
          if(!event.active) simulation.alphaTarget(0.3).restart(); 
          d.fx=d.x; d.fy=d.y; 
      })
      .on('drag', (event,d) => { 
          d.fx=event.x; d.fy=event.y; 
          // Disable D3's drag while zooming/panning
          d3.select(this).attr("transform", `translate(${d.fx},${d.fy})`);
      })
      .on('end', (event,d) => { 
          if(!event.active) simulation.alphaTarget(0); 
          d.fx=null; d.fy=null; 
      })
    );

  node.append('circle')
    .attr('r', d => rScale(d.degree))
    .attr('fill', '#3b82f6');

  // ðŸ‘‡ MODIFIED: Text position centered (x=0, y=0) because we use CSS for centering
  node.append('text')
    .text(d => d.label)
    .attr('x', 0)
    .attr('y', 0);
  // ðŸ‘† END MODIFIED

  // --- Zoom Logic ---
  const zoom = d3.zoom()
      .scaleExtent([0.1, 4]) // Min zoom 10%, Max zoom 400%
      .on('zoom', (event) => {
          g.attr('transform', event.transform);
          // Need to call moveTooltip to update the tooltip position during zoom
          if (currentTooltipLock || d3.select('#tooltip').style('display') === 'block') {
             moveTooltip(event);
          }
      });

  svg.call(zoom);
  // --- End Zoom Logic ---


  const tooltip = d3.select('#tooltip');
  let currentTooltipLock = null; 

  function dismissLock() {
      if (currentTooltipLock) {
          if (currentTooltipLock.id) {
              node.select('circle').filter(n => n === currentTooltipLock)
                   .attr('stroke', '#fff').attr('stroke-width', 1.5);
          }
          currentTooltipLock = null;
      }
  }

  function updateTooltip(event, d, isNode) {
    let htmlContent;
    
    if (isNode) {
        htmlContent = `<strong>${d.label}</strong><br/>Connections: ${d.degree}<br/>Animals: ${d.animals.join(', ')}`;
    } else {
        const sourceLabel = d.source.label || d.source.id;
        const targetLabel = d.target.label || d.target.id;
        const status = d.isReciprocal ? ' (Reciprocal Route)' : ' (One-Way Route)';
        htmlContent = `<strong>Route ID: ${d.RouteID}</strong><br/>
                       ${sourceLabel} â†’ ${targetLabel}${status}<br/>
                       Animals: ${d.Animals}`;
    }

    tooltip.style('display', 'block')
           .html(htmlContent);
  }

  function handleLinkInteraction(event, d) {
      if (currentTooltipLock && currentTooltipLock.id) {
          dismissLock();
      }
      
      updateTooltip(event, d, false);
      moveTooltip(event);
      
      if (currentTooltipLock === d) {
          currentTooltipLock = null;
          tooltip.style('display', 'none');
      } else if (event.type === 'click') {
          currentTooltipLock = d;
      }
  }

  function handleLinkMouseOut() {
      if (currentTooltipLock === null) {
          tooltip.style('display', 'none');
      }
  }
  
  function handleNodeInteraction(event, d, circleElement) {
      if (currentTooltipLock && !currentTooltipLock.id) {
          dismissLock();
      }
      
      if (currentTooltipLock && currentTooltipLock.id) {
          node.select('circle').filter(n => n === currentTooltipLock)
               .attr('stroke', '#fff').attr('stroke-width', 1.5);
      }
      
      updateTooltip(event, d, true);
      moveTooltip(event);
      
      if (currentTooltipLock === d) {
          d3.select(circleElement).attr('stroke', '#fff').attr('stroke-width', 1.5);
          currentTooltipLock = null;
          tooltip.style('display', 'none');
      } else if (event.type === 'click') {
          currentTooltipLock = d;
          d3.select(circleElement).attr('stroke', '#000').attr('stroke-width', 2);
      } else if (event.type === 'mouseover') {
          if (currentTooltipLock !== d) {
             d3.select(circleElement).attr('stroke', '#000').attr('stroke-width', 2);
          }
      }
  }

  function handleNodeMouseOut(event, d, circleElement) {
      if (currentTooltipLock !== d) {
          d3.select(circleElement).attr('stroke', '#fff').attr('stroke-width', 1.5);
      }
      
      if (currentTooltipLock === null) {
          tooltip.style('display', 'none');
      }
  }

  // ðŸ‘‡ MODIFIED: Function to calculate tooltip position accounting for zoom/pan
  function moveTooltip(event) {
    // Get the current transformation state (zoom/pan)
    const transform = d3.zoomTransform(svg.node());
    
    // Convert screen coordinates to coordinates relative to the zoomed SVG content
    const x = event.sourceEvent ? event.sourceEvent.pageX : event.pageX;
    const y = event.sourceEvent ? event.sourceEvent.pageY : event.pageY;

    tooltip.style('left', (x + 12) + 'px')
           .style('top', (y + 12) + 'px'); 
  }
  // ðŸ‘† END MODIFIED

  // --- Event Listeners ---
  
  link.on('mouseover', function(event, d) { handleLinkInteraction(event, d); })
      .on('mousemove', moveTooltip)
      .on('mouseout', handleLinkMouseOut)
      .on('click', function(event, d) { handleLinkInteraction(event, d); });

  node.select('circle')
      .on('mouseover', function(event, d) { handleNodeInteraction(event, d, this); })
      .on('mousemove', moveTooltip)
      .on('mouseout', function(event, d) { handleNodeMouseOut(event, d, this); })
      .on('click', function(event, d) { handleNodeInteraction(event, d, this); });

  // Function to dismiss any lock on chart background click
  svg.on('click', (event) => {
    // Check if the click event originated from the SVG canvas itself
    if (event.target.tagName === 'svg' || event.target.tagName === 'rect' && d3.select(event.target).attr('class') === 'overlay') {
        dismissLock();
        tooltip.style('display', 'none');
    }
  });


  simulation.on('tick', () => {
    link.attr('d', d => {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist === 0) return null;
        const rSource = rScale(d.source.degree);
        const rTarget = rScale(d.target.degree);
        const sx = d.source.x + (dx / dist) * rSource;
        const sy = d.source.y + (dy / dist) * rSource;
        const tx = d.target.x - (dx / dist) * rTarget;
        const ty = d.target.y - (dy / dist) * rTarget;
        
        const dr = d.isReciprocal ? dist * 0.8 : dist * 0.8;
        
        const allLinksBetween = links.filter(l => 
            (l.source.id === d.source.id && l.target.id === d.target.id && l.Animals === d.Animals) || 
            (l.source.id === d.target.id && l.target.id === d.source.id && l.Animals === d.Animals)
        );
        let arcFlag = 0;
        if (allLinksBetween.length > 1) {
             const indexInFiltered = allLinksBetween.findIndex(l => l.source.id === d.source.id && l.target.id === d.target.id);
             if (indexInFiltered === 0) {
                 arcFlag = 0; 
             } else {
                 arcFlag = 1; 
             }
        }
        d.pathString = `M${sx},${sy}A${dr},${dr} 0 0,${arcFlag} ${tx},${ty}`;
        return d.pathString;
    });
    node.attr('transform', d => `translate(${d.x},${d.y})`);

    linkLabel.attr('transform', d => {
        const path = link.filter(p => p.source.id === d.source.id && p.target.id === d.target.id && p.Animals === d.Animals).node();
        if (!path) return `translate(0, 0)`;

        const totalLength = path.getTotalLength();
        const point = path.getPointAtLength(totalLength / 2);
        
        return `translate(${point.x}, ${point.y})`;
    });
  });

  // --- Filtering Logic (Combined Handler) ---
  
  function updateVisualization() {
    const selectedAnimal = animalDropdown.node().value;
    const selectedCity = cityDropdown.node().value;
    const duration = 300; 

    let activeLinks = links;
    let activeLabeledLinks = labeledLinks;
    let connectedNodeIds = new Set();
    
    if (selectedAnimal !== 'all') {
        activeLinks = activeLinks.filter(l => l.Animals === selectedAnimal);
        activeLabeledLinks = activeLabeledLinks.filter(l => l.Animals === selectedAnimal);
    }
    
    if (selectedCity !== 'all') {
        const cityLinks = links.filter(l => 
            (l.source.id === selectedCity || l.target.id === selectedCity)
        );
        
        if (selectedAnimal !== 'all') {
            activeLinks = cityLinks.filter(l => l.Animals === selectedAnimal);
        } else {
            activeLinks = cityLinks;
        }
        
        activeLabeledLinks = activeLabeledLinks.filter(l => 
            (l.source.id === selectedCity || l.target.id === selectedCity)
        );

        connectedNodeIds.add(selectedCity);
        activeLinks.forEach(l => {
            connectedNodeIds.add(l.source.id);
            connectedNodeIds.add(l.target.id);
        });

    } else if (selectedAnimal !== 'all') {
         activeLinks.forEach(l => {
            connectedNodeIds.add(l.source.id);
            connectedNodeIds.add(l.target.id);
         });
         nodes.forEach(n => { 
            if(n.animals.includes(selectedAnimal)) connectedNodeIds.add(n.id); 
         });
    } else {
        nodes.forEach(n => connectedNodeIds.add(n.id));
    }


    link.transition().duration(duration)
      .style('opacity', d => activeLinks.includes(d) ? 1.0 : 0)
      .style('pointer-events', d => activeLinks.includes(d) ? 'auto' : 'none');
    
    linkLabel.transition().duration(duration)
      .style('opacity', d => activeLabeledLinks.includes(d) ? 1.0 : 0)
      .style('pointer-events', d => activeLabeledLinks.includes(d) ? 'auto' : 'none');

    node.transition().duration(duration)
      .style('opacity', d => connectedNodeIds.has(d.id) ? 1.0 : 0)
      .style('pointer-events', d => connectedNodeIds.has(d.id) ? 'auto' : 'none');
  }

  animalDropdown.on('change', updateVisualization);
  cityDropdown.on('change', updateVisualization);
  
  window.addEventListener('resize', () => {
    const w = container.node().clientWidth, h = container.node().clientHeight;
    svg.attr('width', w).attr('height', h);
    simulation.force('center', d3.forceCenter(w/2, h/2));
    simulation.alpha(0.3).restart();
  });

})();
</script>
</body>
</html>