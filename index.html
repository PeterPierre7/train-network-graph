<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Train Network with Animal Filter from GSheet</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
#layout { display:flex; height:100vh; width:100vw; margin:0; }
#controls { width:220px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
#chart { flex:1; height:100vh; }
.node circle { stroke:#fff; stroke-width:1.2px; cursor:pointer; }
.node text { font-size:12px; pointer-events:none; }
.link { fill:none; stroke-opacity:0.8; cursor:pointer; }
.tooltip { position:absolute; background:rgba(0,0,0,0.8); color:#fff; padding:6px 8px; border-radius:4px; font-size:13px; pointer-events:none; display:none; }
</style>
</head>
<body>

<div id="layout">
  <div id="controls">
    <h3>Filter</h3>
    <label for="animalFilter">Animal:</label>
    <select id="animalFilter">
      <option value="">All animals</option>
    </select>
  </div>
  <div id="chart"></div>
</div>
<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function(){

  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const citiesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const routesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;

  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(citiesUrl), d3.csv(routesUrl)]);

  const nodes = nodesRaw.map(d => ({
    id: d.CityName,
    label: d.CityName,
    animals: d.HouseAnimals ? d.HouseAnimals.split(',').map(a=>a.trim()) : [],
    degree: 0
  }));

  const links = linksRaw.map(d => ({
    source: d.FromCity,
    target: d.ToCity,
    Animals: d.Animals
  }));

  // Compute degree
  links.forEach(l => {
    const s = nodes.find(n => n.id === l.source);
    const t = nodes.find(n => n.id === l.target);
    if(s) s.degree += 1;
    if(t) t.degree += 1;
  });

  // Animal dropdown
  const animalSet = new Set();
  links.forEach(l => { if(l.Animals) animalSet.add(l.Animals.trim()); });
  nodes.forEach(n => n.animals.forEach(a => animalSet.add(a)));
  const animalDropdown = d3.select('#animalFilter');
  Array.from(animalSet).sort().forEach(a => {
    animalDropdown.append('option').attr('value', a).text(a);
  });

  const container = d3.select('#chart');
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;
  const svg = container.append('svg').attr('width', width).attr('height', height);

  // Arrowhead
  svg.append('defs').append('marker')
    .attr('id', 'arrowhead')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 15)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .attr('markerUnits', 'userSpaceOnUse')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#999');

  const rScale = d3.scaleSqrt().domain(d3.extent(nodes,d=>d.degree)).range([6,24]);

  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d=>d.id).distance(120).strength(0.8))
    .force('charge', d3.forceManyBody().strength(-250))
    .force('center', d3.forceCenter(width/2,height/2))
    .force('collision', d3.forceCollide().radius(d=>rScale(d.degree)+4));

  const link = svg.append('g').attr('class','links')
    .selectAll('path')
    .data(links)
    .join('path')
    .attr('class','link')
    .attr('stroke-width', 5)
    .attr('stroke', '#999')
    .attr('marker-end', 'url(#arrowhead)');

  const node = svg.append('g').attr('class','nodes')
    .selectAll('g')
    .data(nodes)
    .join('g')
    .attr('class','node')
    .call(d3.drag()
      .on('start',(event,d)=>{ if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
      .on('drag',(event,d)=>{ d.fx=event.x; d.fy=event.y; })
      .on('end',(event,d)=>{ if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; })
    );

  node.append('circle')
    .attr('r', d => rScale(d.degree))
    .attr('fill','#3b82f6');

  node.append('text')
    .text(d => d.label)
    .attr('x', d => rScale(d.degree)+4)
    .attr('y', 4);

  const tooltip = d3.select('#tooltip');
  function showTooltipLink(event,d){
    tooltip.style('display','block').html(`<strong>${d.source.label} â†’ ${d.target.label}</strong><br/>Animals: ${d.Animals}`);
  }
  function showTooltipNode(event,d){
    tooltip.style('display','block').html(`<strong>${d.label}</strong><br/>Connections: ${d.degree}<br/>Animals: ${d.animals.join(', ')}`);
    d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',1.5);
  }
  function moveTooltip(event){ tooltip.style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px'); }
  function hideTooltip(event,d){ tooltip.style('display','none'); d3.select(event.currentTarget).attr('stroke','#fff').attr('stroke-width',1.2); }

  link.on('mouseover', event => tooltip.style('display','block')).on('mousemove', moveTooltip).on('mouseout', hideTooltip);
  node.select('circle').on('mouseover', showTooltipNode).on('mousemove', moveTooltip).on('mouseout', hideTooltip);

  simulation.on('tick', ()=>{
    link.attr('d', d => {
      // offset start/end by node radius
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const rSource = rScale(nodes.find(n=>n.id===d.source.id).degree);
      const rTarget = rScale(nodes.find(n=>n.id===d.target.id).degree);
      const ratioSource = rSource / dist;
      const ratioTarget = rTarget / dist;
      const sx = d.source.x + dx*ratioSource;
      const sy = d.source.y + dy*ratioSource;
      const tx = d.target.x - dx*ratioTarget;
      const ty = d.target.y - dy*ratioTarget;
      const dr = dist*0.8; // curve radius
      return `M${sx},${sy}A${dr},${dr} 0 0,1 ${tx},${ty}`;
    });
    node.attr('transform', d=>`translate(${d.x},${d.y})`);
  });

  animalDropdown.on('change', function(){
    const selectedAnimal = this.value;
    const activeLinks = selectedAnimal 
      ? links.filter(l => l.Animals === selectedAnimal)
      : links;

    const connectedNodeIds = new Set();
    activeLinks.forEach(l => { connectedNodeIds.add(l.source); connectedNodeIds.add(l.target); });

    nodes.forEach(n => { if(selectedAnimal && n.animals.includes(selectedAnimal)) connectedNodeIds.add(n.id); });

    link
      .attr('stroke', d => activeLinks.includes(d) ? '#999' : '#ccc')
      .attr('stroke-opacity', d => activeLinks.includes(d) ? 0.8 : 0.1)
      .attr('marker-end', 'url(#arrowhead)'); // always keep marker

    node.select('circle').attr('fill', d => connectedNodeIds.has(d.id) ? '#3b82f6' : '#aaa');
  });

  window.addEventListener('resize', ()=>{
    const w = container.node().clientWidth, h = container.node().clientHeight;
    svg.attr('width', w).attr('height', h);
    simulation.force('center', d3.forceCenter(w/2,h/2));
    simulation.alpha(0.3).restart();
  });

})();
</script>
</body>
</html>
