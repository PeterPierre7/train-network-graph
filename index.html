<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Train Network - Toggable Layout</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
    body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
    #layout { display:flex; height:100vh; width:100vw; margin:0; }
    #controls { width:220px; background:#f8f9fa; padding:15px; border-right:1px solid #ccc; box-sizing:border-box; }
    #controls select { width: 100%; margin-bottom: 15px; padding: 5px; }
    #chart { flex:1; height:100vh; }
    
    /* Map Styles */
    .country {
        fill: #e0e0e0; /* Light gray for land */
        stroke: #ccc;
        stroke-width: 0.5px;
    }
    .sphere {
        fill: #f0f8ff; /* Light blue for ocean */
    }
    .map-element {
        transition: opacity 0.5s;
    }

    .node circle { stroke:#fff; stroke-width:1.5px; cursor:pointer; }
    .node text { 
        font-weight: bold;
        fill: #000; 
        pointer-events:none; 
        text-anchor: middle;
        dominant-baseline: central;
        text-shadow: 0 0 3px #ccc, 0 0 3px #ccc, 0 0 3px #ccc; 
    }
    .link { fill:none; cursor:pointer; }
    
    /* *** Link label styles *** */
    .link-label text { 
        font-size: 8px; /* Small font size for links */
        fill: #000; 
        pointer-events: none; /* Crucial: allows clicking on the link path underneath */
        text-anchor: middle;
        dominant-baseline: central; 
        text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff; 
        font-weight: bold;
    }
    .link-label .reciprocal { fill: green; }
    .link-label .one-way { fill: red; }

    .tooltip { 
        position:absolute; 
        background:rgba(0,0,0,0.8); 
        color:#fff; 
        padding:8px 12px;
        border-radius:4px; 
        font-size:14px;
        pointer-events:none; 
        display:none; 
        line-height: 1.4;
    }
    .tooltip strong {
        color: #ffcc00; 
    }
    .green-text { color: lightgreen; }
    .red-text { color: red; }
    #mapToggle {
        padding: 8px 10px;
        margin-top: 10px;
        width: 100%;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: bold;
    }
    #mapToggle.active {
        background-color: #28a745;
    }
</style>
</head>
<body>

<div id="layout">
  <div id="controls">
    <h3>Filter</h3>
    <label for="cityFilter">City:</label>
    <select id="cityFilter">
      </select>
    <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
    <label for="animalFilter">Animal:</label>
    <select id="animalFilter">
      </select>
    <hr style="margin: 15px 0; border: none; border-top: 1px solid #ccc;">
    <label for="reciprocalFilter">Route Type:</label>
    <select id="reciprocalFilter">
        <option value="all">Show All Routes</option>
        <option value="reciprocal">Only Reciprocal (Two-way)</option>
        <option value="one-way">Only One-way</option>
      </select>
    <button id="mapToggle" class="active">Toggle Map (ON)</button>
  </div>
  <div id="chart"></div>
</div>
<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script>
(async function(){

  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const citiesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const routesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;
  
  const world = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
  
  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(citiesUrl), d3.csv(routesUrl)]);

  const nodes = nodesRaw.map(d => ({
    id: d.CityName,
    label: d.CityName,
    animals: d.HouseAnimals ? d.HouseAnimals.split(',').map(a => a.trim()) : [],
    longitude: +d.Longitude, 
    latitude: +d.Latitude,
    degree: 0,
    fx: null, 
    fy: null,
    x: 0,
    y: 0 
  }));

  const links = linksRaw.map(d => ({
    source: d.FromCity,
    target: d.ToCity,
    Animals: d.Animals,
    RouteID: d.RouteID,
    isReciprocal: false
  }));
  
  // Map to hold route details for reciprocal check
  const reciprocalRoutes = {};

  links.forEach(l => {
    const s = nodes.find(n => n.id === l.source);
    const t = nodes.find(n => n.id === l.target);
    if(s) s.degree += 1;
    if(t) t.degree += 1;
    
    // Use an animal-specific reciprocal key
    const reciprocalKey = [l.source, l.target].sort().join('|') + '|' + l.Animals;
    
    if (!reciprocalRoutes[reciprocalKey]) {
        reciprocalRoutes[reciprocalKey] = [];
    }
    reciprocalRoutes[reciprocalKey].push(l);
  });
  
  // Second pass to identify and update reciprocal links
  links.forEach(link => {
      const reciprocalKey = [link.source, link.target].sort().join('|') + '|' + link.Animals;
      const routes = reciprocalRoutes[reciprocalKey];
      
      if (routes.length === 2) {
          routes.forEach(r => r.isReciprocal = true);
          
          const [routeA, routeB] = routes;
          if (routeA === link) {
             link.otherRouteID = routeB.RouteID;
          } else if (routeB === link) {
             link.otherRouteID = routeA.RouteID;
          }
      }
  });

  // =======================================================
  // LOGIC: Simplify Links for Display (MAX 3 LINES)
  // =======================================================
  const uniqueDisplayLinks = {};
  const aggregatedAnimals = {}; 

  links.forEach(l => {
      const sortedCities = [l.source, l.target].sort();
      const canonicalCityPair = sortedCities.join('|');
      
      // Store ALL animal details for the tooltip
      if (!aggregatedAnimals[canonicalCityPair]) {
          aggregatedAnimals[canonicalCityPair] = [];
      }
      
      const animalDetail = {
          name: l.Animals,
          isReciprocal: l.isReciprocal,
          source: l.source,
          target: l.target
      };
      
      // Only add unique entries
      const isUniqueInAggregated = !aggregatedAnimals[canonicalCityPair].some(a => 
          a.name === animalDetail.name && 
          ((a.isReciprocal && animalDetail.isReciprocal) || 
           (!a.isReciprocal && !animalDetail.isReciprocal && a.source === animalDetail.source && a.target === animalDetail.target)) 
      );

      if (isUniqueInAggregated) {
           aggregatedAnimals[canonicalCityPair].push(animalDetail);
      }
      
      let displayKey;
      if (l.isReciprocal) {
          // 1. One line for all reciprocal routes
          displayKey = canonicalCityPair + '|reciprocal';
      } else {
          // 2 & 3. One line for each one-way direction
          displayKey = l.source + '|' + l.target + '|one-way';
      }

      if (!uniqueDisplayLinks[displayKey]) {
          uniqueDisplayLinks[displayKey] = {
              source: l.source, 
              target: l.target,
              isReciprocal: l.isReciprocal,
              cityPair: canonicalCityPair, 
              directionKey: l.source + '->' + l.target,
              // Store aggregated animals data key for easy lookup later
              animalDataKey: canonicalCityPair 
          };
      }
  });

  const labeledLinks = Object.values(uniqueDisplayLinks);
  
  // Resolve source/target objects
  labeledLinks.forEach(l => {
      l.source = nodes.find(n => n.id === l.source) || l.source;
      l.target = nodes.find(n => n.id === l.target) || l.target;
      
      // Attach the full animal list for permanent label creation
      l.displayAnimals = aggregatedAnimals[l.animalDataKey] || [];
  });

  // Group paths by city pair for curvature indexing
  const pathGroups = {};
  labeledLinks.forEach(l => {
      const sortedCities = [l.source.id || l.source, l.target.id || l.target].sort().join('|');
      if (!pathGroups[sortedCities]) {
          pathGroups[sortedCities] = [];
      }
      pathGroups[sortedCities].push(l);
  });
  
  // Assign index for arc curvature
  Object.values(pathGroups).forEach(group => {
      
      const reciprocalLink = group.find(l => l.isReciprocal);
      const oneWayLinks = group.filter(l => !l.isReciprocal);

      if (reciprocalLink) {
          reciprocalLink.pathIndex = 0; // The single straight line (center position)
      }
      
      // Sort one-way links consistently
      oneWayLinks.sort((a, b) => a.directionKey.localeCompare(b.directionKey));

      oneWayLinks.forEach((link, index) => {
          // pathIndex 1 and 2 for the two parallel curves (outer positions)
          link.pathIndex = index + 1; 
      });
  });

  // --- Dropdown Population ---
  const animalSet = new Set();
  links.forEach(l => { if(l.Animals) animalSet.add(l.Animals.trim()); });
  nodes.forEach(n => n.animals.forEach(a => animalSet.add(a)));
  
  const animalDropdown = d3.select('#animalFilter');
  animalDropdown.append('option').attr('value', 'all').text('Show All');
  Array.from(animalSet).sort().forEach(a => {
    animalDropdown.append('option').attr('value', a).text(a);
  });
  
  const cityDropdown = d3.select('#cityFilter');
  cityDropdown.append('option').attr('value', 'all').text('Show All');
  nodes.map(d => d.id).sort().forEach(city => {
    cityDropdown.append('option').attr('value', city).text(city);
  });
  
  const reciprocalDropdown = d3.select('#reciprocalFilter');
  
  const container = d3.select('#chart');
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;
  const svg = container.append('svg').attr('width', width).attr('height', height);

  const g = svg.append('g'); 
  
  // --- Map Projection and Drawing ---
  const projection = d3.geoMercator()
      .fitSize([width, height], topojson.feature(world, world.objects.countries));

  const path = d3.geoPath().projection(projection);

  const sphere = g.append("path")
      .attr("class", "sphere map-element")
      .attr("d", path({type: "Sphere"}));

  const countries = g.append("g")
      .attr("class", "countries map-element")
      .selectAll("path")
      .data(topojson.feature(world, world.objects.countries).features)
      .join("path")
      .attr("class", "country")
      .attr("d", path);

  function setGeographicalPositions() {
      nodes.forEach(d => {
          if (d.longitude && d.latitude) {
              const [x, y] = projection([d.longitude, d.latitude]);
              d.x = x;
              d.y = y;
              d.fx = x; 
              d.fy = y; 
          }
      });
  }
  setGeographicalPositions(); 

  // --- Force Simulation Configuration and Layout Toggle ---
  const rScaleAbstract = d3.scaleSqrt().domain(d3.extent(nodes, d => d.degree)).range([12, 24]);
  
  const mapBaseRadius = 4;
  const mapMinScaleRatio = 0.5; 
  const mapMaxScaleRatio = 1.5; 
  const linkBaseWidthAbstract = 1.5; 
  const linkBaseWidthMap = 1.5;
  const cityLabelSizeMap = 4;
  const cityLabelSizeAbstract = 10;
  
  // Base curvature magnitude
  const curvature = 0.5; 

  const originalChargeStrength = -350; 
  const originalLinkStrength = 0.4; 
  const linkDistanceAbstract = 150;
  
  const originalCollisionRadius = 5;

  const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links).id(d => d.id).distance(linkDistanceAbstract).strength(0.05))
      .alpha(0.1).alphaTarget(0);
      
  simulation
      .force('charge', null)
      .force('center', null)
      .force('collision', null);

  let isMapMode = true;

  function updateNodeAndLinkStyles() {
      const transform = d3.zoomTransform(svg.node());
      
      node.select('circle').attr('r', d => {
          if (isMapMode) {
              const scaleRatio = Math.max(mapMinScaleRatio, Math.min(mapMaxScaleRatio, 1 / Math.sqrt(transform.k)));
              return mapBaseRadius * scaleRatio;
          } else {
              return rScaleAbstract(d.degree);
          }
      });
      
      link.attr('stroke-width', d => {
          if (isMapMode) {
              const scaleRatio = Math.max(mapMinScaleRatio, Math.min(mapMaxScaleRatio, 1 / Math.sqrt(transform.k)));
              return linkBaseWidthMap * scaleRatio;
          } else {
              return linkBaseWidthAbstract;
          }
      });
      
      node.select('text').style('font-size', d => {
          return isMapMode ? `${cityLabelSizeMap}px` : `${cityLabelSizeAbstract}px`;
      });
      
      // Update link label size with zoom/layout
      linkLabel.select('text').style('font-size', d => {
          if (isMapMode) {
              const scaleRatio = Math.max(mapMinScaleRatio, Math.min(mapMaxScaleRatio, 1 / Math.sqrt(transform.k)));
              return `${8 * scaleRatio}px`;
          } else {
              return '8px';
          }
      });


      if (!isMapMode && simulation.force('collision')) {
          simulation.force('collision').radius(d => rScaleAbstract(d.degree) + originalCollisionRadius);
          simulation.alpha(0.3).restart();
      }
  }

  function setAbstractLayout() {
      isMapMode = false;
      d3.select('#mapToggle').text('Toggle Map (OFF)').attr('class', '');
      g.selectAll(".map-element").style('opacity', 0).style('pointer-events', 'none');

      nodes.forEach(d => {
          d.fx = null;
          d.fy = null;
      });

      simulation
          .force('link').strength(originalLinkStrength).distance(linkDistanceAbstract);
      simulation
          .force('charge', d3.forceManyBody().strength(originalChargeStrength)) 
          .force('center', d3.forceCenter(width/2, height/2)) 
          .force('collision', d3.forceCollide().radius(d => rScaleAbstract(d.degree) + originalCollisionRadius));
      
      updateNodeAndLinkStyles(); 
      simulation.alpha(1).restart();
  }

  function setGeographicalLayout() {
      isMapMode = true;
      d3.select('#mapToggle').text('Toggle Map (ON)').attr('class', 'active');
      g.selectAll(".map-element").style('opacity', 1).style('pointer-events', 'auto');
      
      setGeographicalPositions(); 
      
      simulation
          .force('link').strength(0.05).distance(200);
      simulation
          .force('charge', null)
          .force('center', null)
          .force('collision', null);
      
      updateNodeAndLinkStyles();
      
      simulation.alpha(1).restart();
  }

  d3.select('#mapToggle').on('click', () => {
      if (isMapMode) {
          setAbstractLayout();
      } else {
          setGeographicalLayout();
      }
  });

  // Define arrowheads 
  g.append('defs').append('marker')
    .attr('id', 'arrowhead-green-start').attr('viewBox', '-0 -5 10 10').attr('refX', -10).attr('refY', 0).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto-start-reverse').append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', 'green');
  g.append('defs').append('marker')
    .attr('id', 'arrowhead-green-end').attr('viewBox', '-0 -5 10 10').attr('refX', 10).attr('refY', 0).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto').append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', 'green');
  
  g.append('defs').append('marker')
    .attr('id', 'arrowhead-red-end').attr('viewBox', '-0 -5 10 10').attr('refX', 10).attr('refY', 0).attr('markerWidth', 6).attr('markerHeight', 6).attr('orient', 'auto').append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', 'red');


  // --- Link Path Drawing Group ---
  const link = g.append('g').attr('class', 'links')
    .selectAll('path').data(labeledLinks).join('path').attr('class', 'link')
    .attr('stroke', d => d.isReciprocal ? 'green' : 'red')
    .attr('marker-start', d => d.isReciprocal ? 'url(#arrowhead-green-start)' : null)
    .attr('marker-end', d => d.isReciprocal ? 'url(#arrowhead-green-end)' : 'url(#arrowhead-red-end)');

  // --- Link Label Group: Multi-line labels ---
  const linkLabel = g.append('g').attr('class', 'link-labels')
    .selectAll('g').data(labeledLinks).join('g').attr('class', 'link-label');

  // Clear existing content and build the multi-line label
  linkLabel.html(null); 
  
  linkLabel.append('text')
    .each(function(d) {
        const textElement = d3.select(this);
        
        let relevantAnimals;
        if (d.isReciprocal) {
            const reciprocalRoutes = d.displayAnimals.filter(a => a.isReciprocal);
            // Filter unique animals on reciprocal routes
            relevantAnimals = [...new Map(reciprocalRoutes.map(item => [item['name'], item])).values()];
        } else {
            // Only include one-way routes that match THIS link's specific direction (source -> target)
            relevantAnimals = d.displayAnimals.filter(a => 
                !a.isReciprocal && 
                a.source === d.source.id && 
                a.target === d.target.id
            );
        }

        // Limit to the first 3 entries for the permanent label
        relevantAnimals.slice(0, 3).forEach((a, i) => {
            let symbol;
            let className;
            
            if (a.isReciprocal) {
                symbol = '<-->';
                className = 'reciprocal';
            } else {
                symbol = '-->';
                className = 'one-way';
            }
            
            // Adjust starting dy to create vertical separation within the text block
            textElement.append('tspan')
                .attr('class', className)
                .attr('x', 0) // Align all tspan elements horizontally at x=0
                // Start with -1em to shift the whole block up/down more aggressively.
                .attr('dy', (i === 0 ? '-1em' : '1em')) 
                .text(`${a.name} ${symbol}`);
        });
    });

  // --- Node Group ---
  const node = g.append('g').attr('class', 'nodes')
    .selectAll('g').data(nodes).join('g').attr('class', 'node')
    .call(d3.drag()
      .on('start', (event,d) => { 
          if(!event.active) simulation.alphaTarget(0.3).restart(); 
          d.fx=d.x; d.fy=d.y; 
      })
      .on('drag', (event,d) => { 
          d.fx=event.x; d.fy=event.y; 
      })
      .on('end', (event,d) => { 
          if(!event.active) simulation.alphaTarget(0); 
          
          if (isMapMode) {
              const [x, y] = projection([d.longitude, d.latitude]);
              d.fx = x;
              d.fy = y;
              d.x = x;
              d.y = y;
              simulation.alpha(1).restart();
          } else {
              d.fx = null;
              d.fy = null;
          }
      })
    );

  node.append('circle').attr('fill', '#3b82f6');
  node.append('text').text(d => d.label).attr('x', 0).attr('y', 0);

  // --- Zoom Logic and Tooltip ---
  const zoom = d3.zoom()
      .scaleExtent([0.5, 8]) 
      .on('zoom', (event) => {
          g.attr('transform', event.transform);
          if (currentTooltipLock || d3.select('#tooltip').style('display') === 'block') {
             moveTooltip(event);
          }
          updateNodeAndLinkStyles(); 
      });

  svg.call(zoom);


  const tooltip = d3.select('#tooltip');
  let currentTooltipLock = null; 

  function dismissLock() {
      if (currentTooltipLock) {
          if (currentTooltipLock.id) {
              node.select('circle').filter(n => n === currentTooltipLock).attr('stroke', '#fff').attr('stroke-width', 1.5);
          }
          currentTooltipLock = null;
      }
  }
  
  // Function to create the aggregated tooltip content 
  function getLinkTooltipContent(d) {
      const cityPair = d.cityPair; 
      const allAnimals = aggregatedAnimals[cityPair] || [];

      // Filter out only the unique reciprocal animals
      const reciprocalAnimals = [...new Map(allAnimals.filter(a => a.isReciprocal).map(item => [item['name'], item])).values()];
      
      // Filter for one-way animals
      const oneWayAnimals = allAnimals.filter(a => !a.isReciprocal);
      
      const sourceLabel = d.source.label || d.source.id;
      const targetLabel = d.target.label || d.target.id;
      
      let htmlContent = `<strong>Route: ${sourceLabel} to ${targetLabel}</strong><hr style="margin: 5px 0; border: none; border-top: 1px solid #ccc;"/>`;

      // 1. Reciprocal Section
      if (reciprocalAnimals.length > 0) {
          htmlContent += reciprocalAnimals.map(a => 
              `<span class="green-text">${a.name} &lt;--&gt;</span>` 
          ).join('<br/>') + '<br/>';
      }

      // 2. One-Way Section
      if (oneWayAnimals.length > 0) {
          
          const oneWayList = oneWayAnimals.map(a => {
              
              // Corrected logic for arrow direction in tooltip
              let finalSymbol;
              if (a.source === d.source.id && a.target === d.target.id) {
                  finalSymbol = '-->'; 
              } else if (a.source === d.target.id && a.target === d.source.id) {
                  finalSymbol = '<--'; 
              } else {
                  finalSymbol = '-?-'; 
              }
              
              return `<span class="red-text">${a.name} ${finalSymbol}</span>`;
          }).join('<br/>');

          htmlContent += oneWayList;
      }
      
      if (reciprocalAnimals.length === 0 && oneWayAnimals.length === 0) {
           htmlContent += "<em>No animal routes found.</em>";
      }

      return htmlContent;
  }

  function updateTooltip(event, d, isNode) {
    let htmlContent;
    if (isNode) {
        htmlContent = `<strong>${d.label}</strong><br/>Connections: ${d.degree}<br/>Animals: ${d.animals.join(', ')}`;
    } else {
        htmlContent = getLinkTooltipContent(d);
    }
    tooltip.style('display', 'block').html(htmlContent);
  }

  function handleLinkInteraction(event, d) {
      if (currentTooltipLock && currentTooltipLock.id) { dismissLock(); }
      updateTooltip(event, d, false);
      moveTooltip(event);
      if (currentTooltipLock === d) {
          currentTooltipLock = null;
          tooltip.style('display', 'none');
      } else if (event.type === 'click') { currentTooltipLock = d; }
  }
  function handleLinkMouseOut() {
      if (currentTooltipLock === null) { tooltip.style('display', 'none'); }
  }
  function handleNodeInteraction(event, d, circleElement) {
      if (currentTooltipLock && !currentTooltipLock.id) { dismissLock(); }
      if (currentTooltipLock && currentTooltipLock.id) { node.select('circle').filter(n => n === currentTooltipLock).attr('stroke', '#fff').attr('stroke-width', 1.5); }
      updateTooltip(event, d, true);
      moveTooltip(event);
      if (currentTooltipLock === d) {
          d3.select(circleElement).attr('stroke', '#fff').attr('stroke-width', 1.5);
          currentTooltipLock = null;
          tooltip.style('display', 'none');
      } else if (event.type === 'click') {
          currentTooltipLock = d;
          d3.select(circleElement).attr('stroke', '#000').attr('stroke-width', 2);
      } else if (event.type === 'mouseover') {
          if (currentTooltipLock !== d) { d3.select(circleElement).attr('stroke', '#000').attr('stroke-width', 2); }
      }
  }
  function handleNodeMouseOut(event, d, circleElement) {
      if (currentTooltipLock !== d) { d3.select(circleElement).attr('stroke', '#fff').attr('stroke-width', 1.5); }
      if (currentTooltipLock === null) { tooltip.style('display', 'none'); }
  }
  function moveTooltip(event) {
    const x = event.sourceEvent ? event.sourceEvent.pageX : event.pageX;
    const y = event.sourceEvent ? event.sourceEvent.pageY : event.sourceEvent.pageY;

    tooltip.style('left', (x + 12) + 'px').style('top', (y + 12) + 'px'); 
  }


  // --- Event Listeners ---
  link.on('mouseover', function(event, d) { handleLinkInteraction(event, d); })
      .on('mousemove', moveTooltip).on('mouseout', handleLinkMouseOut)
      .on('click', function(event, d) { handleLinkInteraction(event, d); });

  node.select('circle').on('mouseover', function(event, d) { handleNodeInteraction(event, d, this); })
      .on('mousemove', moveTooltip).on('mouseout', function(event, d) { handleNodeInteraction(event, d, this); })
      .on('click', function(event, d) { handleNodeInteraction(event, d, this); });

  svg.on('click', (event) => {
    if (event.target.tagName === 'svg' || event.target.tagName === 'path' && (d3.select(event.target).attr('class') === 'sphere' || d3.select(event.target).attr('class') === 'country')) {
        dismissLock();
        tooltip.style('display', 'none');
    }
  });


  simulation.on('tick', () => {
    node.attr('transform', d => `translate(${d.x},${d.y})`);

    
    link.attr('d', (d, i) => {
        const sourceNode = d.source;
        const targetNode = d.target;

        if (!sourceNode || !targetNode || !sourceNode.x || !targetNode.x) return null; 

        const dx = targetNode.x - sourceNode.x;
        const dy = targetNode.y - sourceNode.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist === 0) return null;
        
        // Get dynamic radius for link adjustment
        const rSource = d3.select(node.filter(n => n.id === sourceNode.id).node()).select('circle').attr('r') || mapBaseRadius;
        const rTarget = d3.select(node.filter(n => n.id === targetNode.id).node()).select('circle').attr('r') || mapBaseRadius;
        
        const sx = sourceNode.x + (dx / dist) * rSource;
        const sy = sourceNode.y + (dy / dist) * rSource;
        const tx = targetNode.x - (dx / dist) * rTarget;
        const ty = targetNode.y - (dy / dist) * rTarget;
        
        const adjustedDist = dist - rSource - rTarget;
        
        // PathIndex 0 = Reciprocal (straight line)
        if (d.pathIndex === 0) {
            d.pathString = `M${sx},${sy}L${tx},${ty}`;
            d.midpoint = [(sx + tx) / 2, (sy + ty) / 2];
            d.angle = Math.atan2(dy, dx); // Angle in radians
        } else {
            // PathIndex 1 & 2 = One-way (parallel curves in one direction)
            
            const offsetMagnitude = (d.pathIndex === 1) ? 0.2 : 0.8; 
            const offset = offsetMagnitude; 
            const dr_factor = adjustedDist * curvature * offset;

            const arcFlag = 0; 
            const dr = adjustedDist + dr_factor; 
            
            if (dr <= adjustedDist) { 
                 d.pathString = `M${sx},${sy}L${tx},${ty}`;
            } else {
                 d.pathString = `M${sx},${sy}A${dr},${dr} 0 0,${arcFlag} ${tx},${ty}`;
            }
            
            // For curved paths, we still use the straight-line midpoint and angle for positioning the label.
            d.midpoint = [(sx + tx) / 2, (sy + ty) / 2];
            d.angle = Math.atan2(dy, dx); // Angle in radians
        }

        return d.pathString;
    });

    // *** FIX: Use parallel offset to separate the labels along the length of the line ***
    const parallelOffset = 30; // Distance to shift the labels along the line's direction

    linkLabel.attr('transform', function(d) {
        if (!d.midpoint) return 'translate(0,0)'; 
        
        const [mx, my] = d.midpoint;
        const angle = d.angle; // Angle in radians
        
        let perpendicularOffsetMagnitude;
        let finalParallelOffset = 0; // Default parallel offset
        
        if (d.pathIndex === 0) {
            // Index 0 (Reciprocal/Straight line) -> Center (0 perp offset, 0 parallel offset)
            perpendicularOffsetMagnitude = 0;
            finalParallelOffset = 0; 
        } else if (d.pathIndex === 1) {
            // Index 1 (One-way/Curve 1) -> *** Changed to positive perpendicular offset ***
            perpendicularOffsetMagnitude = 30; 
            finalParallelOffset = -parallelOffset; // Shift towards the source node
        } else { // d.pathIndex === 2
            // Index 2 (One-way/Curve 2) -> *** Changed to a larger positive perpendicular offset ***
            perpendicularOffsetMagnitude = 60; 
            finalParallelOffset = parallelOffset; // Shift towards the target node
        }
        
        // 1. Calculate the PERPENDICULAR (side-to-side) translation
        const offsetX_perp = perpendicularOffsetMagnitude * (-Math.sin(angle));
        const offsetY_perp = perpendicularOffsetMagnitude * (Math.cos(angle));

        // 2. Calculate the PARALLEL (along-the-line) translation
        const offsetX_par = finalParallelOffset * (Math.cos(angle));
        const offsetY_par = finalParallelOffset * (Math.sin(angle));


        // The final label position is the midpoint + perpendicular offset + parallel offset
        return `translate(${mx + offsetX_perp + offsetX_par}, ${my + offsetY_perp + offsetY_par})`;
    })
    .style('opacity', d => link.filter(l => l === d).style('opacity')); // Match link visibility
  });

  // --- Filtering Logic ---
  function updateVisualization() {
    const selectedAnimal = animalDropdown.node().value;
    const selectedCity = cityDropdown.node().value;
    const selectedReciprocal = reciprocalDropdown.node().value; 

    const duration = 300; 

    let activeLinks = labeledLinks;
    let connectedNodeIds = new Set();
    
    // 1. Filter by Animal
    if (selectedAnimal !== 'all') {
        const filteredCityPairs = new Set();
        // The filter must check if the animal is present in the *aggregated* list for that visual link
        activeLinks = activeLinks.filter(l => {
            if (l.isReciprocal) {
                // Check if the selected animal is a reciprocal animal on this link
                return l.displayAnimals.some(a => a.isReciprocal && a.name === selectedAnimal);
            } else {
                // Check if the selected animal is a one-way animal matching the link's direction
                return l.displayAnimals.some(a => 
                    !a.isReciprocal && 
                    a.name === selectedAnimal && 
                    a.source === l.source.id && 
                    a.target === l.target.id
                );
            }
        });
    }

    // 2. Filter by Reciprocal Status
    if (selectedReciprocal !== 'all') {
        const isReciprocal = (selectedReciprocal === 'reciprocal');
        activeLinks = activeLinks.filter(l => l.isReciprocal === isReciprocal);
    }
    
    // 3. Filter by City
    if (selectedCity !== 'all') {
        activeLinks = activeLinks.filter(l => 
            (l.source.id === selectedCity || l.target.id === selectedCity)
        );
    } 
    
    // 4. Determine Active Nodes
    activeLinks.forEach(l => {
        connectedNodeIds.add(l.source.id);
        connectedNodeIds.add(l.target.id);
    });

    if (selectedAnimal !== 'all') {
         nodes.forEach(n => { 
            if(n.animals.includes(selectedAnimal)) connectedNodeIds.add(n.id); 
         });
    }

    if (selectedCity !== 'all') {
        connectedNodeIds.add(selectedCity);
    } 
    
    if (selectedAnimal === 'all' && selectedCity === 'all' && connectedNodeIds.size === 0) {
        nodes.forEach(n => connectedNodeIds.add(n.id));
    }


    // 5. Apply Transitions
    // Links (Paths)
    link.transition().duration(duration)
      .style('opacity', d => activeLinks.includes(d) ? 1.0 : 0)
      .style('pointer-events', d => activeLinks.includes(d) ? 'auto' : 'none');
      
    // Link Labels
    linkLabel.transition().duration(duration)
      .style('opacity', d => activeLinks.includes(d) ? 1.0 : 0);
    
    // Nodes (Circles and Text)
    node.transition().duration(duration)
      .style('opacity', d => connectedNodeIds.has(d.id) ? 1.0 : 0)
      .style('pointer-events', d => connectedNodeIds.has(d.id) ? 'auto' : 'none');
      
    // Node Text
    node.select('text').transition().duration(duration)
       .style('opacity', d => connectedNodeIds.has(d.id) ? 1.0 : 0);
  }

  animalDropdown.on('change', updateVisualization);
  cityDropdown.on('change', updateVisualization);
  reciprocalDropdown.on('change', updateVisualization);
  
  // Resize handler
  window.addEventListener('resize', () => {
    const w = container.node().clientWidth, h = container.node().clientHeight;
    svg.attr('width', w).attr('height', h);
    
    projection.fitSize([w, h], topojson.feature(world, world.objects.countries));
    
    g.selectAll(".sphere").attr("d", path({type: "Sphere"}));
    g.selectAll(".country").attr("d", path);

    if (isMapMode) {
        setGeographicalPositions();
    } else {
        simulation.force('center', d3.forceCenter(w/2, h/2));
    }

    updateNodeAndLinkStyles();
    simulation.alpha(0.1).alphaTarget(0).restart();
  });
  
  // Initial run
  updateNodeAndLinkStyles(); 
  simulation.alpha(1).restart(); 
  updateVisualization(); 

})();
</script>
</body>
</html>