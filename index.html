<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Train Network Graph Filtered by Animal</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    
    #layout { display: flex; height: 100vh; width: 100vw; margin: 0; }
    #controls { width: 220px; background: #f8f9fa; padding: 15px; border-right: 1px solid #ccc; box-sizing: border-box; }
    #chart { flex: 1; height: 100vh; }

    .link { stroke: #999; stroke-opacity: 0.6; cursor: pointer; }
    .node { stroke: #fff; stroke-width: 1.2px; cursor: pointer; }
    .tooltip { position: absolute; background: rgba(0,0,0,0.8); color: #fff; padding: 6px 8px; border-radius: 4px; font-size: 13px; pointer-events: none; display: none; }
  </style>
</head>
<body>

<div id="layout">
  <div id="controls">
    <h3>Filter</h3>
    <label for="animalFilter">Animal:</label>
    <select id="animalFilter">
      <option value="">All animals</option>
    </select>
  </div>

  <div id="chart"></div>
</div>

<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function(){
  const sheetId = '1TKsoH-CVhXjJ7vMptfTukRO6wWO_1KGpS76yHu29Omc';
  const nodesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const linksUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;

  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(nodesUrl), d3.csv(linksUrl)]);

  const nodes = nodesRaw.map(d => ({
    id: d.CityID,
    label: d.CityName || d.CityID,
    lat: +(d.Latitude || 0),
    lon: +(d.Longitude || 0),
    visible: true
  }));

  const links = linksRaw.map(d => ({
    source: d.FromCity,
    target: d.ToCity,
    weight: +(d.PassengersPerDay || 1),
    distance: +(d.DistanceKm || 0),
    Animals: d.Animals || ''
  }));

  // Populate animal dropdown
  const animalSet = new Set();
  links.forEach(l => {
    if(l.Animals){
      l.Animals.split(',').forEach(a => animalSet.add(a.trim()));
    }
  });
  const animalDropdown = d3.select('#animalFilter');
  Array.from(animalSet).sort().forEach(a => {
    animalDropdown.append('option').attr('value', a).text(a);
  });

  // SVG setup
  const container = d3.select('#chart');
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;
  const svg = container.append('svg').attr('width', width).attr('height', height);

  const degreeExtent = d3.extent(nodes, d => d.degree || 0);
  const rScale = d3.scaleSqrt().domain([0,10]).range([6, 24]); // node radius

  const weightExtent = d3.extent(links, d => d.weight);
  const linkWidth = d3.scaleLinear().domain(weightExtent).range([1,6]);

  const maxDist = d3.max(links, d => d.distance) || 1;
  const distScale = d3.scaleLinear().domain([0, maxDist]).range([50, 300]);

  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(d => d.distance ? distScale(d.distance) : 120).strength(0.8))
    .force('charge', d3.forceManyBody().strength(-250))
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collision', d3.forceCollide().radius(d => rScale(d.degree || 1)+4));

  let link = svg.append('g').attr('class','links').selectAll('line')
    .data(links)
    .join('line')
    .attr('class','link')
    .attr('stroke-width', d => linkWidth(d.weight));

  let node = svg.append('g').attr('class','nodes').selectAll('g')
    .data(nodes)
    .join('g')
    .call(d3.drag()
      .on('start', (event,d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
      .on('drag', (event,d) => { d.fx=event.x; d.fy=event.y; })
      .on('end', (event,d) => { if (!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; })
    );

  node.append('circle')
    .attr('r', d => rScale(d.degree || 1))
    .attr('class','node')
    .attr('fill', '#3b82f6');

  node.append('text')
    .text(d => d.label)
    .attr('x', d => rScale(d.degree || 1)+4)
    .attr('y', 4)
    .style('font-size','12px');

  const tooltip = d3.select('#tooltip');
  function showTooltipLink(event,d){
    tooltip.style('display','block').html(`<strong>${d.source.label} â†’ ${d.target.label}</strong><br/>Animals: ${d.Animals}`);
    d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',2);
  }
  function showTooltipNode(event,d){
    tooltip.style('display','block').html(`<strong>${d.label}</strong><br/>Connections: ${d.degree || 0}`);
    d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',1.5);
  }
  function moveTooltip(event){ tooltip.style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px'); }
  function hideTooltip(event,d){ tooltip.style('display','none'); d3.select(event.currentTarget).attr('stroke','#fff').attr('stroke-width',1.2); }

  link.on('mouseover', showTooltipLink).on('mousemove', moveTooltip).on('mouseout', hideTooltip);
  node.select('circle').on('mouseover', showTooltipNode).on('mousemove', moveTooltip).on('mouseout', hideTooltip);

  simulation.on('tick', () => {
    link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Animal filter: hide only nodes not connected to filtered links
  animalDropdown.on('change', function(){
    const selectedAnimal = this.value;

    let filteredLinks;
    if(selectedAnimal){
      filteredLinks = links.filter(l => l.Animals && l.Animals.split(',').map(a=>a.trim()).includes(selectedAnimal));
    } else {
      filteredLinks = links;
    }

    const connectedNodeIds = new Set();
    filteredLinks.forEach(l => { connectedNodeIds.add(l.source); connectedNodeIds.add(l.target); });

    // Update link visibility
    link.style('display', d => filteredLinks.includes(d) ? 'block' : 'none');

    // Update node visibility
    node.style('display', d => connectedNodeIds.has(d.id) ? 'block' : 'none');

    simulation.alpha(0.3).restart();
  });

  // Responsive
  window.addEventListener('resize', () => {
    const w = container.node().clientWidth, h = container.node().clientHeight;
    svg.attr('width', w).attr('height', h);
    simulation.force('center', d3.forceCenter(w/2,h/2));
    simulation.alpha(0.3).restart();
  });

})();
</script>
</body>
</html>
