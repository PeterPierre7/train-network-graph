<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Train Network Graph</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #chart { width:100vw; height:100vh; }
    .link { stroke: #999; stroke-opacity: 0.6; }
    .node { stroke: #fff; stroke-width: 1.2px; cursor: pointer; }
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 13px;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
<div id="chart"></div>
<div class="tooltip" id="tooltip"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function(){
  const sheetId = 'PUT_YOUR_SHEET_ID_HERE'; // <<--- REPLACE THIS
  const nodesUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=Cities`;
  const linksUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=TrainRoutes`;

  // Fetch CSVs
  const [nodesRaw, linksRaw] = await Promise.all([d3.csv(nodesUrl), d3.csv(linksUrl)]);

  // Normalize & parse numbers
  const nodes = nodesRaw.map(d => ({
    id: d.CityID,
    label: d.CityName || d.CityID,
    lat: +(d.Latitude || 0),
    lon: +(d.Longitude || 0),
    size: +(d.TotalPassengers || 1)
  }));

  const links = linksRaw.map(d => ({
    source: d.FromCity,
    target: d.ToCity,
    weight: +(d.PassengersPerDay || d.Weight || 1),
    distance: +(d.DistanceKm || 0)
  }));

  // Build SVG
  const container = d3.select('#chart');
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  const svg = container.append('svg')
    .attr('width', width)
    .attr('height', height);

  // Scales
  const sizeExtent = d3.extent(nodes, d => d.size);
  const rScale = d3.scaleSqrt().domain(sizeExtent).range([4,24]);

  const weightExtent = d3.extent(links, d => d.weight);
  const linkWidth = d3.scaleLinear().domain(weightExtent).range([1,6]);

  const maxDist = d3.max(links, d => d.distance) || 1;
  const distScale = d3.scaleLinear().domain([0, maxDist]).range([50, 300]);

  // Force simulation
  const simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(d => d.distance ? distScale(d.distance) : 120).strength(0.8))
    .force('charge', d3.forceManyBody().strength(-250))
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collision', d3.forceCollide().radius(d => rScale(d.size)+4));

  // Draw links
  const link = svg.append('g')
      .attr('class','links')
    .selectAll('line')
    .data(links)
    .join('line')
      .attr('class','link')
      .attr('stroke-width', d => linkWidth(d.weight));

  // Draw nodes
  const node = svg.append('g')
      .attr('class','nodes')
    .selectAll('g')
    .data(nodes)
    .join('g')
      .call(d3.drag()
        .on('start', (event,d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x; d.fy = d.y;
        })
        .on('drag', (event,d) => { d.fx = event.x; d.fy = event.y; })
        .on('end', (event,d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null; d.fy = null;
        })
      );

  node.append('circle')
    .attr('r', d => rScale(d.size))
    .attr('class','node')
    .attr('fill', '#3b82f6')
    .on('mouseover', (event, d) => showTooltip(event, d))
    .on('mousemove', (event, d) => moveTooltip(event))
    .on('mouseout', hideTooltip);

  node.append('text')
    .text(d => d.label)
    .attr('x', d => rScale(d.size) + 4)
    .attr('y', 4)
    .style('font-size','12px');

  // Tooltip
  const tooltip = d3.select('#tooltip');
  function showTooltip(event, d){
    tooltip.style('display','block')
      .html(`<strong>${d.label}</strong><br/>Total passengers: ${d.size}`);
    d3.select(event.currentTarget).attr('stroke','#000').attr('stroke-width',1.5);
  }
  function moveTooltip(event){
    tooltip.style('left', (event.pageX + 12) + 'px').style('top', (event.pageY + 12) + 'px');
  }
  function hideTooltip(event, d){
    tooltip.style('display','none');
    d3.select(event.currentTarget).attr('stroke','#fff').attr('stroke-width',1.2);
  }

  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Responsive
  window.addEventListener('resize', () => {
    const w = container.node().clientWidth, h = container.node().clientHeight;
    svg.attr('width', w).attr('height', h);
    simulation.force('center', d3.forceCenter(w/2, h/2));
    simulation.alpha(0.3).restart();
  });

})();
</script>
</body>
</html>
